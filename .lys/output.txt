     1                                  [BITS 16] ;endast för -f bin
     2                                  [ORG 0x7C00] ;endast för -f bin
     3                                  
     4                                  
     5                                  ;section .text
     6                                  _start: 
     7 00000000 31C0                        xor ax,ax      ; We want a segment of 0 for DS for this question
     8 00000002 8ED8                        mov ds,ax      ;     Set AX to appropriate segment value for your situation
     9 00000004 8EC0                        mov es,ax      ; In this case we'll default to ES=DS
    10 00000006 BB0080                      mov bx,0x8000  ; Stack segment can be any usable memory
    11                                  
    12 00000009 FA                          cli            ; Disable interrupts to circumvent bug on early 8088 CPUs
    13 0000000A 8ED3                        mov ss,bx      ; This places it with the top of the stack @ 0x80000.
    14 0000000C 89C4                        mov sp,ax      ; Set SP=0 so the bottom of stack will be @ 0x8FFFF
    15 0000000E FB                          sti            ; Re-enable interrupts
    16                                  
    17                                  
    18 0000000F FC                          cld ; clear direction flags
    19 00000010 B80300                      mov ax, 03h  ;Clear the screen
    20 00000013 CD10                        int 10h ; BIOS call for clearing 
    21                                      
    22                                      ;mov cs, ax ;it fucks the printing up!!!
    23                                     ; mov sp, 0x8000
    24 00000015 B40E                        mov ah, 0x0e
    25 00000017 BE[FC00]                    mov si, realModeMsg 
    26                                      
    27 0000001A E8AF00                      call printmsg  
    28                                      
    29 0000001D F4                          hlt
    30                                      
    31                                      
    32                                      
    33                                  ;section .text    
    34                                  a20_gate_fast: 
    35 0000001E 31C0                        xor ax,ax
    36                                      ;There is no guarantee that this works on a system! It works in most cases,
    37 00000020 E492                        in al, 0x92 ;but not always. TODO: Implement at least one more algorithm enabling A20
    38 00000022 0C02                        or al, 2
    39 00000024 E692                        out 0x92, al
    40 00000026 E81A00                      call check_a20
    41 00000029 87DB                        xchg bx, bx
    42 0000002B 83F800                      cmp  ax, 0
    43 0000002E 7508                        jne  enable_A20__done ;jump if A20 enabled
    44 00000030 BE[0701]                    mov si,A20errorMsg
    45 00000033 E99600                      jmp printmsg
    46 00000036 EBE6                        jmp a20_gate_fast
    47                                      
    48                                  
    49                                  ;section .text
    50                                  enable_A20__done: 
    51 00000038 31C0                        xor ax,ax
    52 0000003A B40E                        mov ah, 0x0e
    53 0000003C BE[1101]                    mov si, A20sucess
    54 0000003F 8A04                        mov al, [si]
    55 00000041 EB65                        jmp protected_mode
    56                                      ;jmp printmsg ;HERE
    57                                      ;jmp load_gdt
    58                                      ;call kernel_entry
    59                                      
    60                                      
    61                                      ;http://www.independent-software.com/operating-system-development-enabling-a20-line.html
    62                                      ; https://stackoverflow.com/questions/52668637/is-my-understanding-of-the-a20-line-check-code-correct
    63                                  check_a20:
    64 00000043 9C                          pushf                                  ;Backup the current flags onto the stack
    65                                                                             ;Backup the below registers onto the stack
    66 00000044 1E                          push ds                                ;|
    67 00000045 06                          push es                                ;|
    68 00000046 57                          push di                                ;|
    69 00000047 56                          push si                                ;-----
    70                                  
    71 00000048 FA                          cli                                    ;Disable interupts
    72                                  
    73 00000049 31C0                        xor ax, ax                             ; ax = 0
    74 0000004B 8EC0                        mov es, ax                             ;es = ax
    75                                  
    76 0000004D F7D0                        not ax                                 ; ax = 0xFFFF
    77 0000004F 8ED8                        mov ds, ax                             ; ds = ax
    78                                  
    79 00000051 BF0005                      mov di, 0x0500                         ;Boot signature part one (0x55)
    80 00000054 BE1005                      mov si, 0x0510                         ;Boot signature part two (0xAA)
    81                                  
    82 00000057 268A05                      mov al, byte [es:di]                   ;al = value at AA:55
    83 0000005A 50                          push ax                                ;Backup ax register onto the stack
    84                                  
    85 0000005B 3E8A04                      mov al, byte [ds:si]                   ;al = value at 55:AA
    86 0000005E 50                          push ax                                ;Backup al onto the stack
    87                                  
    88 0000005F 26C60500                    mov byte [es:di], 0x00                 ;Memory location AA:55 = 0
    89 00000063 3EC604FF                    mov byte [ds:si], 0xFF                 ;Memory location at 55:AA = 0xFF
    90                                  
    91 00000067 26803DFF                    cmp byte [es:di], 0xFF                 ;Does value at AA:55 = 0xFF? If so, this means A20 is disabled
    92                                  
    93 0000006B 58                          pop ax                                 ;Restore saved ax register
    94 0000006C 3E8804                      mov byte [ds:si], al                   ;Set 55:AA to al
    95                                  
    96 0000006F 58                          pop ax                                 ;Restore ax register
    97 00000070 268805                      mov byte [es:di], al                   ;set AA:55 to al
    98                                  
    99 00000073 B80000                      mov ax, 0                              ;Return status of this function = 0 (Disabled)
   100 00000076 7406                        je check_a20__exit                     ;A20 is disabled. Go to check_a20__exit
   101                                  
   102 00000078 B80100                      mov ax, 1                               ;Return status of this function = 1 (Enabled)
   103 0000007B EB01                        jmp check_a20__exit
   104 0000007D C3                          ret 
   105                                      
   106                                  check_a20__exit:
   107                                                                             ;Backup registers
   108 0000007E 5E                          pop si
   109 0000007F 5F                          pop di
   110 00000080 07                          pop es
   111 00000081 1F                          pop ds
   112 00000082 9D                          popf                                   ;Backup flags
   113                                  
   114 00000083 C3                          ret                                    ;Return
   115                                  
   116                                      
   117                                    ;FOUND ON OSDev.org. Similarly implemented on simple-x86-bootloader 
   118                                  load_gdt:
   119 00000084 B8[3601]                    mov ax, gdtend
   120 00000087 BB[1E01]                    mov bx, gdt
   121 0000008A 29D8                        sub ax, bx  ;compute GDT's limit
   122 0000008C A3[3601]                    mov WORD [gdtptr], ax
   123                                  
   124 0000008F 6631C0                      xor eax, eax  ;compute linear of GDT
   125 00000092 8CD8                        mov ax, ds
   126 00000094 66C1E004                    shl eax, 4
   127 00000098 6631DB                      xor ebx, ebx
   128 0000009B 66BB[1E010000]              mov ebx, gdt
   129 000000A1 6601D8                      add eax, ebx
   130 000000A4 66A3[3801]                  mov DWORD [gdtptr + 2], eax
   131                                  
   132                                    
   133                                    
   134                                  protected_mode: 
   135 000000A8 FA                          cli
   136                                          ;loader
   137                                  
   138                                      ;loaderend
   139 000000A9 0F0116[3C01]                lgdt [GDT_DESCRIPTOR]     ;load  gdt
   140 000000AE E9(0010)                jmp 0x01000
   141 000000B1 0F20C0                      mov eax, cr0
   142 000000B4 83C801                      or  ax, 1
   143 000000B7 0F22C0                      mov cr0, eax 
   144                                  
   145 000000BA 31C0                        xor ax,ax
   146 000000BC B81000                      mov ax,10h
   147 000000BF 8ED8                        mov ds,ax
   148 000000C1 8EC0                        mov es,ax
   149 000000C3 8EE0                        mov fs,ax
   150 000000C5 8EE8                        mov gs,ax
   151 000000C7 8ED0                        mov ss,ax
   152                                  
   153                                  
   154                                  
   155                                  
   156 000000C9 E9(0010)                    jmp 0x01000
   157                                  
   158                                      ;call kernel_entry
   159                                      ;jmp 0x08:init_pm
   160                                  
   161                                      ;jmp init_pm
   162                                          
   163                                          
   164                                      
   165                                  
   166                                      ;;functions for general use
   167                                    printmsg:
   168 000000CC 8A04                        mov al, [si]
   169 000000CE 83C601                      add si, 1
   170 000000D1 3C0A                        cmp al, 0xa
   171 000000D3 7501                        jne print_interrupt
   172 000000D5 C3                          ret
   173                                      ; alternative way: 
   174                                      ;lodsb 
   175                                      ;or al,al
   176                                      ;jz print_interrupt
   177                                      
   178                                  print_interrupt: 
   179 000000D6 CD10                        int 0x10
   180 000000D8 EBF2                        jmp printmsg
   181                                  
   182                                  
   183                                      
   184                                  [bits 32]
   185                                  init_pm:
   186 000000DA 66B81000                    mov ax, 0x10
   187 000000DE 8ED8                        mov ds, ax
   188 000000E0 8ED0                        mov ss, ax
   189                                  
   190 000000E2 BC00000900                  mov esp, 0x090000  ;set up stack pointer
   191                                  
   192                                      ;mov byte [0xB8000], 88
   193                                     ; mov byte [0xB8000+1], 0x1B
   194                                  
   195                                      ;call dword 0x08:0x01000  ;go to C code
   196 000000E7 E9(00100000)                jmp 0x01000
   197                                  
   198 000000EC C60504800B0059              mov byte [0xB8000+4], 89
   199 000000F3 C60505800B001B              mov byte [0xB8000+5], 0x1B
   200 000000FA EBFE                        jmp $
   201                                      
   202                                      
   203                                      
   204                                      
   205                                      
   206                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   207                                  
   208 000000FC 5265616C206D6F6465-     realModeMsg db "Real mode.", 0xa
   208 00000105 2E0A               
   209 00000107 4572726F7220413230-     A20errorMsg db "Error A20", 0xa
   209 00000110 0A                 
   210 00000111 413230207375636365-     A20sucess db "A20 success!", 0xa
   210 0000011A 7373210A           
   211                                  
   212                                  gdt: ;gdt based on simple-x86-bootloader
   213 0000011E 0000000000000000             db 0, 0, 0, 0, 0, 0, 0, 0
   214                                  gdt_cs: ; flat model
   215 00000126 FFFF0000009BDF00             db 0xFF, 0xFF, 0x0, 0x0, 0x0, 10011011b, 11011111b, 0x0
   216                                  gdt_ds: ; flat model
   217 0000012E FFFF00000093DF00             db 0xFF, 0xFF, 0x0, 0x0, 0x0, 10010011b, 11011111b, 0x0
   218                                  gdtend:
   219                                       ;---------------------------------------------------------
   220                                  gdtptr:
   221 00000136 0000                        dw 0  ; limite
   222 00000138 00000000                    dd 0  ; base
   223                                  
   224                                  GDT_DESCRIPTOR: ; to be loaded by instruction lgdt
   225                                      ; The size is the size of the table subtracted by 1. This is because the
   226                                      ; maximum value of size is 65535, while the GDT can be up to 65536 bytes (a
   227                                      ; maximum of 8192 entries). Further no GDT can have a size of 0. 
   228 0000013C 1700                        dw gdtend - gdt - 1    
   229                                      ; The offset is the linear address of the table itself
   230                                      ;dd gdt
   231                                  ;--------------------------------------------------------------------
   232                                  
   233                                  ;clc 
   234                                  ; Switch to the BIOS (= request low memory size)
   235                                  ;int 0x12
   236                                  ;jmp 0x9d0000
   237                                   
   238                                  ;----------------------------------------------;
   239                                  ; Bootloader signature must be located
   240                                  ; at bytes #511 and #512.
   241                                  ; Fill with 0 in between.
   242                                  ; $  = address of the current line
   243                                  ; $$ = address of the 1st instruction
   244                                  ;----------------------------------------------;
   245 0000013E 00<rep C0h>             times 510 - ($-$$) db 0
   246 000001FE 55AA                    dw        0xaa55
